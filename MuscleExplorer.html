<!doctype html>
<html>
<!-- Muscle-Spring-Damper-Projectile simulation, called "Muscle Explorer" for now. 2017. Stephen M. Deban, Department of Integrative Biology, University of South Florida, Tampa. -->

<head>
  <meta name="viewport" content="width=device-width">
  <style>
    .graph {
      float: left;
      margin: auto;
      padding: auto;
      width: 350px;
      height: 190px;
    }

    .variable {
      margin-right: 4px;
      padding: 1px;
      display: flex;
    }

    .variable input {
      flex: 1;
      margin-left: 5px;
      color: royalblue;
      font-size: 1em;
      width: 4em;
    }

    #graphBlock {
      float: left;
      max-width: 75%;
    }

    #controlBlock {
      float: left;
      margin: 4px;
      margin-top: 2px;
      padding: 0px;
      width: 20%;
      width: 350px;
      height: 100%;
      border: 0px solid #aaaaaa;
      line-height: 150%;
      font-size: 100%;
      font-family: "Lucida Grande", Verdana, Arial, sans-serif;
    }

    #footer {
      clear: both;
      padding: 10px;
      text-align: center;
      color: #cccccc;
    }

    a {
      color: royalblue;
      text-decoration: none;
    }

    h1 {
      font-family: "Lucida Grande", Verdana, Arial, sans-serif;
      font-size: 180%;
      color: firebrick;
      margin: 0.3em;
      margin-left: 0;
    }

    body {
      font-family: sans-serif;
    }

  </style>
</head>

<body onload="springMass();">

  <div id="controlBlock">
    <h1><em>Muscle Explorer</em></h1> Deban Lab @ USF
    <br/>
    <br/>
    <b title="General simulation settings.">Settings</b>
    <div class="variable" title="Duration of simulation in seconds.">Duration (s):
      <input type="number" min="0.01" max="100" step="0.01" id="duration" value="0.08">
    </div>
    <div class="variable" title="Number of time steps in integration. Increase if traces are jittery.">Steps:
      <input type="range" id="steps" value="20" min="5" max="300" step="5" oninput="stepsOutput.value = steps.value+'k'">
      <output style="color: royalblue" id="stepsOutput">20k</output>
    </div>
    <br>
    <b title="Physiological muscle parameters.">Muscle</b>
    <div class="variable" title="Muscle length in meters at which isometric force peaks. Not the same as resting or initial length, below.">Muscle L0 (m):
      <input type="number" id="muscleL0" value="0.02">
    </div>
    <div class="variable" title="Muscle mass in kg. Can be set independently of length and P0, therefore can be unrealistic. Used to determine the inertial muscle mass, below.">Muscle mass (kg):
      <input type="number" id="muscleMass" value="1e-5">
    </div>
    <div class="variable" title="Maximum isometric muscle force in newtons.">Muscle P0 (N):
      <input type="number" id="muscleP0" value="0.2">
    </div>
    <div class="variable" title="Maximum velocity of unloaded muscle shortening in meters per second.">Muscle Vmax (m/s):
      <input type="number" id="muscleVmax" value="0.3">
    </div>
    <div class="variable" title="Curvature of force-velocity relation. Higher is more curved. Value of 3 is about right for frog limb muscle with a power ratio of 1.1.">Muscle F-V Curvature:
      <input type="number" id="curveFV" value="3">
    </div>
    <div class="variable" title="Muscle length at start of trial, as fraction of muscle L0.">Muscle init. length (L0):
      <input type="number" id="muscleStartLength" value="1.2">
    </div>
    <div class="variable" title="Duration of muscle excitation in seconds.">Excitation (s):
      <input type="number" id="excitationTime" value="0.03">
    </div>
    <br/>
    <b title="Inertial and viscous damping of the muscle mass. Higher values reduce vibrations that can occur with a small muscle mass and stiff spring.">Damping of Muscle</b>
    <div class="variable" title="Muscle mass that is accelerated when the muscle shortens, as a fraction of muscle mass.">Inertial mass (muscle mass):
      <input type="number" step="0.01" min="0.01" max="1.0" id="muscleFraction" value="0.3">
    </div>
    <div class="variable" title="Viscous damping of the inertial muscle mass, with damping force proportional to velocity.">Damping constant (N s/m):
      <input type="number" id="damper" value="0.01">
    </div>
    <br/>
    <b title="The tendon, aponeurosis or cuticular elastic element between the muscle and projectile.">Tendon / Spring</b>
    <div class="variable" title="Stiffness of spring between muscle and projectile, in newtons per meter. Spring is Hookean (F=kx), with a single k. ">Spring constant (N/m):
      <input type="number" id="spring" value="40">
    </div>
    <div class="variable" title="Length in meters at which spring exerts no force. Has no effect on projectile movement, just starting position.">Spring slack length (m):
      <input type="number" id="springL0" value="0.02">
    </div>

    <br/>
    <b title="Prescribe the range of mechanical advantage or gearing values between the spring and the projectile as well as the duration of the change and the conditions that trigger the change.">Appendage Leverage Change</b>
    <div class="variable" title="Start changing gearing at this time unless other conditions are met first, such as a muscle force or muscle length threshold.">Latch time (s):
      <input type="number" id="latchTime" value="0.06">
    </div>
    <div class="variable" title="Start leverage change when this muscle length is reached, as fraction of muscle L0.">Length threshold (L0):
      <input type="number" id="lengthThreshold" value="0.3">
    </div>
    <div class="variable" title="Start leverage change at this muscle force, as fraction of muscle P0.">Force threshold (P0):
      <input type="number" id="forceThreshold" value="0.7">
    </div>
    <div class="variable" title="Duration of the change in leverage in seconds.">Latch duration (s):
      <input type="number" id="durGearChange" value="0.002">
    </div>
    <div class="variable" title="Starting gear ratio of leverage change, the reciprocal of mechanical advantage.">Initial gear ratio:
      <input type="number" id="initGearRatio" value="10000">
    </div>
    <div class="variable" title="Ending gear ratio. A value of 1 would be no mechanical advantage.">Final gear ratio:
      <input type="number" id="finalGearRatio" value="1">
    </div>
    <br/>
    <b title="The mass being accelerated by the muscle-spring.">Projectile</b>
    <div class="variable" title="Mass of the projectile in kg.">Projectile mass (kg):
      <input type="number" id="mass" value="1e-04">
    </div>

    <br />
    <button title="Apply the settings" onclick="springMass()">Apply new values</button>
    <button title="Download the displayed data as csv file." onclick="downloadFile(allData, 'MusExpData' + (1503000000000 - Date.now()) + '.csv');">Download data</button>
    <br />
    <br />
    <a href="Instructions.html" target="_blank" title="Open documentation in a new window.">Documentation page</a>
    <br />
  </div>

  <div id="graphBlock">
    <div title="Muscle length vs time." class="graph" id="chart_01"></div>
    <div title="Muscle force vs time. Force is constrained to be positive, i.e., shortening." class="graph" id="chart_03"></div>
    <div title="Muscle velocity vs time. Positive velocity is the muscle shortening." class="graph" id="chart_02"></div>
    <div title="Absolute muscle power vs time, calculated as muscle velocity x muscle force. Not mass-specific power (unless the muscle mass is 1 kg)." class="graph" id="chart_04"></div>
    <div title="Absolute muscle work vs time, calculated as cumulative muscle force x amount of shortening. Not mass specific." class="graph" id="chart_13"></div>
    <div title="Projectile position vs time." class="graph" id="chart_05"></div>
    <div title="Projectile velocity vs time." class="graph" id="chart_06"></div>
    <div title="Projectile acceleration vs time." class="graph" id="chart_07"></div>
    <div title="Mass-specific projectile power vs time. Calculated as projectile velocity x acceleration." class="graph" id="chart_08"></div>
    <div title="Spring length vs time. Constrained to be equal to or longer than initial length." class="graph" id="chart_09"></div>
    <div title="Spring velocity vs time. Positive velocity is spring shortening." class="graph" id="chart_10"></div>
    <div title="Muscle excitation vs time. Multiplied by the muscle force derived from the length-force and force-velocity curves to ramp up muscle force over time." class="graph" id="chart_11"></div>
    <div title="Muscle relative force (as a fraction of P0) vs length. Both potential (pink) and realized (purple) force-length trajectories are shown for the realized range of lengths." class="graph" id="chart_12"></div>
    <div title="Muscle force vs velocity. Both potential (pink) and realized (purple) force-velocity trajectories are shown for the realized range of velocities." class="graph" id="chart_14"></div>
    <div title="Gear ratio vs time. The profile prescribed for the changing gear ratio between the spring and projectile. The reciprocal of leverage or mechanical advantage." class="graph" id="chart_15"></div>
  </div>

  <div id="footer">Muscle Explorer. 2017. Stephen M. Deban, Department of Integrative Biology, University of South Florida, Tampa. </div>

  <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
  <script type="text/javascript">
    //
    /*   Simulation uses a Runge-Kutta 4th Order (RK4) integration. At large time steps, RK4 performs well because it is refining the estimate in each time step by taking a weighted average of four estimates. Other integrators like Euler and Verlet need absurdly small time steps for the same accuracy, which on balance is not as efficient. RK4 is the gold standard for the balance of performance and accuracy. It is not symplectic, which means that energy is not strictly conserved, but the losses for our purposes are tiny and can be minimized with a small time step. Author: Stephen M. Deban, University of South Florida. */
    // If enter key is pressed, then run the simulation with the entered values.
    document.onkeypress = function(e) {
      var e = e || window.event; // Assing window event to e, if there is an event.
      var charCode = (typeof e.which == "number") ? e.which : e.keyCode;
      if (charCode == 13) springMass(); // Run simulation if the key pressed is the enter key
    }

    // Load google chart API for graphing.
    google.charts.load('current', {
      'packages': ['corechart']
    }); // Load the corechart package which has line charts and others.

    // TODO: Check if local web storage is supported by browser.
    // TODO: Use this in the future for saving and loading data.
    if (typeof(Storage) != "undefined") {
      // Code for localStorage/sessionStorage.
      // NOTE: Not currently used.
    } else {
      alert("No Local Web Storage support!")
    }

    // Simulation settings
    function springMass() { // Start of main simulation function

      // Get values from form in webpage. NOTE: '+' coerces the strings retrieved to numbers. Default values are stored in the form elements in the html.
      var duration = +document.getElementById("duration").value; // Duration in seconds.
      var steps = +document.getElementById("steps").value * 1000; // Steps in simulation. Value from form times 1000.
      var projectileMass = +document.getElementById("mass").value; // Mass in kg.
      var springK = +document.getElementById("spring").value; // Tendon spring constant in N/m. Realistic values not known.
      var dampingConstant = +document.getElementById("damper").value; // Damping constant in Ns/m of damper on muscle mass. Damping may reduce fast oscillation of muscle mass.
      var springL0 = +document.getElementById("springL0").value; // Tendon slack length in m.
      var timeStep = duration / steps; // Size in seconds of time step.
      var time = [];
      for (var i = 0; i != steps + 1; ++i) time[i] = i * timeStep; // Loop to fill time vector with timesteps to be used in graphing. Numbers will not be precise at 14 decimal places, but it doesn't matter.

      // Morphological and physiological parameters
      var muscleL0 = +document.getElementById("muscleL0").value; // Muscle resting length in meters.
      var muscleP0 = +document.getElementById("muscleP0").value; // Muscle isometric force in newtons.
      var muscleVmax = +document.getElementById("muscleVmax").value; // Muscle Vmax in m/s.
      var muscleStartLength = muscleL0 * +document.getElementById("muscleStartLength").value; // Starting length of muscle. Greater than 1.0 will make it start on  descending limb of force-length curve.
      var curveFV = +document.getElementById("curveFV").value; // Curvature of force-velocity relation. Larger values are more curved, with 0 a straight line. Value of 3 is about what frog limb muscle shows. To convert to and from Marsh and Bennett's power ratio use powerRatio=1/(curveFV+2*sqrt(curveFV+1)+2) and curveFV=(1-2*sqrt(powerRatio))/powerRatio
      var powerRatio = 1 / (curveFV + 2 * Math.sqrt(curveFV + 1) + 2); // Convert curveFV to power ratio.
      var muscleMass = +document.getElementById("muscleMass").value; // Combined mass of projector muscles in kg. 8e-06 is realistic.
      var muscleFraction = +document.getElementById("muscleFraction").value; // Fraction of muscle mass that is modeled as accelerated muscle mass.
      var excitationTime = +document.getElementById("excitationTime").value; // Time for muscle excitation in seconds.
      var excitationRate = 2; // Higher numbers have higher peak rate of excitation. Must be greater than 1.

      // Trial parameters that can change between trials.

      // One or more of these conditions can be used to release latch, depending on which if statements in loop are active. The first condition reached will release latch.
      var latchTime = +document.getElementById("latchTime").value; // Timing of latch release in seconds from start of simulation, if used in loop.
      var forceThreshold = +document.getElementById("forceThreshold").value * muscleP0; // Muscle force at which gear ratio drops to 1.
      var lengthThreshold = +document.getElementById("lengthThreshold").value; // Muscle length as percent of starting length at which gear ratio drops to 1.
      var latchTripped = 0; // Sets latch sensor to 0, to allow time of latch release to be captured regardless of condition that triggered it.
      var indexLatchTripped = 0; // Index latch tripped, to be filled later.
      var timeLatchTripped = 0; // Time latch tripped, to be filled later.
      var gearRatioIndex = 0; // Counter to index gear ratio profile array.
      var maxGearRatio = +document.getElementById("initGearRatio").value; // Gear ratio at start of trial.
      var minGearRatio = +document.getElementById("finalGearRatio").value; // Final gear ratio value during launch.
      var durationGearChange = +document.getElementById("durGearChange").value; // Duration of latch release. Value near time step is effectively instantaneous.
      var cumulativeWork = 0; // Place to store the cumulative work done by the muscle.

      // Define arrays of proper length to fill with values later.
      var muscleFLForce = [];
      var muscleForce = [];
      var muscleRelForce = [];
      var musclePower = [];
      var musclePowermW = [];
      var muscleWork = [];
      var muscleWorkmJ = [];
      var springLength = [];
      var springForce = [];
      var springVel = [];
      var projectilePos = [];
      var projectileVel = [];
      var projectileAcc = [];
      var projectilePower = [];
      var gearRatio = [];
      var latchCondition = [];

      // Define function to generate muscle force given length.
      function muscleFLCurve(length) {
        if (length >= 0.6244 && length <= 1.6) {
          var force = -34.045 * Math.pow(length, 5) + 204.74 * Math.pow(length, 4) - 470.16 * Math.pow(length, 3) + 512.43 * Math.pow(length, 2) - 262.9 * length + 50.936; // Takes muscle length relative to L0 from 0 to 1.6 with 1.0 as L0. Up to 1.4 is reliable and based on research values, but up to 1.6 is extrapolated to yield high force values if muscle is stretched. Beyond 1.6 is unreliable, so force at 1.6 is returned.
        } else if (length > 1.6) {
          force = 1.137805;
        } else if (length < 0.6244) {
          force = 0;
        }
        return (force);
      } // Muscle force-length function

      // Create gear ratio profile
      gearRatio = time.map(function(i) { // Create a sigmoidal gear ratio profile, starting to change from max to min at time zero over the specified duration.
        return (1.0009765 * maxGearRatio - minGearRatio) / (1 + Math.pow(2, 10 * -(2 * i - durationGearChange) / -durationGearChange)) + minGearRatio;
      })

      // First time step in simulation.

      // Muscle, spring, projectile and gearing starting conditions.
      var exciteMax = 1; // Maximum excitation level of muscle, with 1 being full excitation.
      var muscleAcc = [];
      muscleAcc[0] = 0; // Starting acceleration of muscle mass in m/s/s.
      var muscleLength = [];
      muscleLength[0] = muscleStartLength; // Starting muscle length in m, set to muscle resting length.
      var muscleVel = [];
      muscleVel[0] = 0; // Starting velocity of muscle shortening in m/s.
      springLength[0] = springL0; // Starting tendon length in m, set to tendon slack length.
      projectileVel[0] = 0; // Starting velocity of tongue (projectile) mass in m/s.
      projectileAcc[0] = 0; // Starting acceleration of tongue (projectile) mass in m/s/s.
      projectilePos[0] = muscleLength[0] + springLength[0]; // Starting position of tongue projectile is defined as sum of starting muscle and spring lengths.
      var muscleExcForce = time.map(function(i) {
        return exciteMax / (1 + Math.pow(excitationRate, 10 * (-2 * i + excitationTime) / excitationTime));
      }); // Defines entire muscle excitation profile array, ramping up from zero to max defined as exciteMax in a sigmoidal fashion by excitationTime.
      var endOfRow = time.map(function(i) {
        return "\n";
      }); // Defines array with EOL to be used in file output array.
      muscleFLForce[0] = muscleFLCurve(muscleLength[0] / muscleL0); // Call function muscleFLCurve to return force from length. See notes below for an explanation.
      var muscleFVForce = [];
      muscleFVForce[0] = (muscleP0 * (muscleVmax - muscleVel[0])) / (curveFV * muscleVel[0] + muscleVmax); // Equation specifying muscle force given muscleVmax, muscleVel, muscleP0 and a F-V curvature. Symmetric around force=velocity.
      muscleForce[0] = muscleFVForce[0] * muscleFLForce[0] * muscleExcForce[0] > 0 ?
        muscleFVForce[0] * muscleFLForce[0] * muscleExcForce[0] : 0; // Final muscle force, calculated from muscle length, velocity and excitation at first time step. Constrained to be positive because a muscle cannot push. Positive when muscle is shortening.
      springForce[0] = (springLength[0] - springL0) * springK > 0 ?
        (springLength[0] - springL0) * springK : 0; // Spring force is calculated from tendon length relative to slack length, and spring constant at current time step, as a Hookean spring: F=kx. F=(current length-slack length)*spring constant. Constrained to be positive or zero because a tendon cannot push. Positive is shortening tendon and projecting tongue mass.
      musclePower[0] = muscleVel[0] * muscleAcc[0]; // Calculate absolute muscle power.

      // Simulation loop: second time step and onward using Runge-Kutta 4th order integration"
      var i = 0; // Set index to 0 so that loop starts with array value 1 (i.e., step 2)
      while (i != steps) { // Loop from 1 (the second step) to number of steps in simulation because arrays start at zero.
        i = i + 1; // Increment index.

        // Calculate first of four parts of Runge-Kutta weighted average. Muscle and projectile mass acceleration, velocity, and position are calculated from muscle and tendon (spring) forces.
        var muscleLength1 = muscleLength[i - 1]; // Last position of muscle mass, to be used in Runge-Kutta integration.
        var muscleVel1 = muscleVel[i - 1]; // Last velocity of muscle shortening, to be used in Runge-Kutta integration
        var projectilePos1 = projectilePos[i - 1]; // Last position of projectile mass.
        var projectileVel1 = projectileVel[i - 1]; // Last velocity of projectile mass.
        var springLength1 = springLength[i - 1]; // Last spring length.
        var springForce1 = springForce[i - 1]; // Last spring force to be used in calculation of projectile acceleration.
        var muscleForce1 = muscleForce[i - 1]; // Last muscle force to be used in calculation of muscle acceleration.
        var muscleAcc1 = (muscleForce1 - springForce1 - dampingConstant * muscleVel1) /
          (muscleMass * muscleFraction); // Muscle mass acceleration is calculated by balance of forces from tendon and muscle in previous time step, using a=F/m: a=(previous muscle force-previous tendon force)/(muscle mass*fraction of muscle mass accelerated). Positive is increasing muscle shortening velocity. Acceleration corresponding to last length and velocity, to be used in Runge-Kutta integration.
        var projectileAcc1 = springForce1 / projectileMass / gearRatio[gearRatioIndex]; // Projectile mass acceleration is calculated using tendon force divided by gear ratio, as a=F/m: a=previous tendon force/projectile mass/gear ratio. Positive or zero. Positive is increasing projection velocity of projectile.

        // Calculate second of four parts of Runge-Kutta weighted average.
        var muscleLength2 = muscleLength1 + muscleVel1 * timeStep / 2; // Intermediate muscle length estimate to be averaged into final estimate using Runge-Kutta integration.
        var muscleVel2 = muscleVel1 + muscleAcc1 * timeStep / 2; // Intermediate muscle velocity estimate.
        var projectilePos2 = projectilePos1 + projectileVel1 * timeStep / 2; // Intermediate projectile position estimate to be averaged into final estimate using Runge-Kutta integration.
        var projectileVel2 = projectileVel1 + projectileAcc1 * timeStep / 2; // Intermediate projectile velocity estimate.
        var muscleFLForce2 = muscleFLCurve(muscleLength2 / muscleL0); // Intermediate muscle force multiplier based on length.
        var muscleFVForce2 = (muscleP0 * (muscleVmax - muscleVel2)) /
          (curveFV * muscleVel2 + muscleVmax); // Intermediate muscle force based on FV curve. Equation specifying muscle force given muscleVmax, muscleVel, muscleP0 and a F-V curvature. Symmetric around force=velocity.
        var muscleForce2 = muscleFVForce2 * muscleFLForce2 * muscleExcForce[i] > 0 ?
          muscleFVForce2 * muscleFLForce2 * muscleExcForce[i] : 0; // Total intermediate muscle force, calculated from muscle length, velocity and excitation at first time step. Constrain muscleForce to be positive because a muscle cannot push. Postitive when muscle is shortening.
        var springLength2 = projectilePos2 - muscleLength2; // Spring length is calculated from muscle length and projectile mass position, as projectile mass position - muscle length.
        var springForce2 = (springLength2 - springL0) * springK > 0 ?
          (springLength2 - springL0) * springK : 0;
        var muscleAcc2 = (muscleForce2 - springForce2 - dampingConstant * muscleVel2) /
          (muscleMass * muscleFraction); // Muscle mass acceleration is calculated by balance of forces from tendon and muscle
        var projectileAcc2 = springForce2 / projectileMass / gearRatio[gearRatioIndex];

        // Calculate third of four parts of Runge-Kutta weighted average.
        var muscleLength3 = muscleLength1 + muscleVel2 * timeStep / 2;
        var muscleVel3 = muscleVel1 + muscleAcc2 * timeStep / 2;
        var projectilePos3 = projectilePos1 + projectileVel2 * timeStep / 2;
        var projectileVel3 = projectileVel1 + projectileAcc2 * timeStep / 2;
        var muscleFLForce3 = muscleFLCurve(muscleLength3 / muscleL0);
        var muscleFVForce3 = (muscleP0 * (muscleVmax - muscleVel3)) / (curveFV * muscleVel3 + muscleVmax);
        var muscleForce3 = muscleFVForce3 * muscleFLForce3 * muscleExcForce[i] > 0 ?
          muscleFVForce3 * muscleFLForce3 * muscleExcForce[i] : 0;
        var springLength3 = projectilePos3 - muscleLength3;
        var springForce3 = (springLength3 - springL0) * springK > 0 ?
          (springLength3 - springL0) * springK : 0;
        var muscleAcc3 = (muscleForce3 - springForce3 - dampingConstant * muscleVel3) /
          (muscleMass * muscleFraction);
        var projectileAcc3 = springForce3 / projectileMass / gearRatio[gearRatioIndex];

        // Calculate fourth of four parts of Runge-Kutta weighted average. Note timestep is not divided by two.
        var muscleLength4 = muscleLength1 + muscleVel3 * timeStep;
        var muscleVel4 = muscleVel1 + muscleAcc3 * timeStep;
        var projectilePos4 = projectilePos1 + projectileVel3 * timeStep;
        var projectileVel4 = projectileVel1 + projectileAcc3 * timeStep;
        var muscleFLForce4 = muscleFLCurve(muscleLength4 / muscleL0);
        var muscleFVForce4 = (muscleP0 * (muscleVmax - muscleVel4)) /
          (curveFV * muscleVel4 + muscleVmax);
        var muscleForce4 = muscleFVForce4 * muscleFLForce4 * muscleExcForce[i] > 0 ?
          muscleFVForce4 * muscleFLForce4 * muscleExcForce[i] : 0;
        var springLength4 = projectilePos4 - muscleLength4;
        var springForce4 = (springLength4 - springL0) * springK > 0 ?
          (springLength4 - springL0) * springK : 0;
        var muscleAcc4 = (muscleForce4 - springForce4 - dampingConstant * muscleVel4) / (muscleMass * muscleFraction);
        var projectileAcc4 = springForce4 / projectileMass / gearRatio[gearRatioIndex];

        // Calculate new positions and velocities by weighted average.
        muscleLength[i] = muscleLength[i - 1] - (muscleVel1 + muscleVel2 * 2 + muscleVel3 * 2 + muscleVel4) *
          timeStep / 6; // Weighted average of four estimates of muscle length, put into vector as definitive muscle length at this time step. Length change is subtracted from old length because muscle is shortening.
        muscleLength[i] = muscleLength[i] > 0.7 * muscleL0 ? muscleLength[i] : muscleLength[i - 1]; // If muscle strain is greater than specified amount, then previous length is used, to prevent extreme shortening.
        muscleVel[i] = muscleVel[i - 1] + (muscleAcc1 + muscleAcc2 * 2 + muscleAcc3 * 2 + muscleAcc4) *
          timeStep / 6; // Weighted average of four estimates of muscle velocity, put into vector as definitive muscle velocity at this time step.
        projectilePos[i] = projectilePos[i - 1] - (projectileVel1 + projectileVel2 * 2 + projectileVel3 * 2 + projectileVel4) * timeStep / 6; // Weighted average of four estimates of projectile position, put into vector as definitive position at this time step. Position change is subtracted from old position because spring is shortening.
        projectileVel[i] = projectileVel[i - 1] + (projectileAcc1 + projectileAcc2 * 2 + projectileAcc3 * 2 + projectileAcc4) * timeStep / 6; // Weighted average of four estimates of projectile velocity, put into vector as definitive velocity at this time step.

        // Calculate definitive muscle force acceleration, spring length and force, and projectile acceleration for this time step.
        muscleFLForce[i] = muscleFLCurve(muscleLength[i] / muscleL0);
        muscleFVForce[i] = (muscleP0 * (muscleVmax - muscleVel[i])) / (curveFV * muscleVel[i] + muscleVmax);
        muscleForce[i] = muscleFVForce[i] * muscleFLForce[i] * muscleExcForce[i] > 0 ?
          muscleFVForce[i] * muscleFLForce[i] * muscleExcForce[i] : 0;
        springLength[i] = (projectilePos[i] - muscleLength[i]) > springL0 ?
          (projectilePos[i] - muscleLength[i]) : springL0; // Calculate definitive spring length for this time step, never shorter than springL0.
        springForce[i] = (springLength[i] - springL0) * springK > 0 ?
          (springLength[i] - springL0) * springK : 0; // Definitive spring force for this time step.
        muscleAcc[i] = (muscleForce[i] - springForce[i] - dampingConstant *
          muscleVel[i]) / (muscleMass * muscleFraction); // Definitive muscle mass acceleration for this time step.
        projectileAcc[i] = springForce[i] / projectileMass / gearRatio[gearRatioIndex]; // Definitive projectile acceleration for this time step.

        // Calculate power and work
        muscleWork[i] = muscleForce[i] * (muscleLength[i - 1] - muscleLength[i]); // Calculate muscle work in joules for this time step.
        cumulativeWork += muscleWork[i]; // Add the current muscle work to the cumulative muscle work.
        muscleWorkmJ[i] = 1000 * cumulativeWork; // Convert work to mJ for graphing.
        musclePower[i] = muscleVel[i] * muscleForce[i]; // Calculate absolute muscle power in W.
        musclePowermW[i] = musclePower[i] * 1000;
        muscleRelForce[i] = muscleForce[i] / muscleP0;
        projectilePower[i] = projectileVel[i] * projectileAcc[i];
        springVel[i] = projectileVel[i] - muscleVel[i];

        // Test for various conditions to determine when latch releases.
        if ((muscleLength[i] < lengthThreshold * muscleL0) || (muscleForce[i] > forceThreshold) || (time[i] > latchTime)) {
          // Asks if muscle length is below threshold value specified, force is above threshold, or time is at preset latch time, and if so, it makes gear ratio from this point onward transition to final value.
          ++gearRatioIndex; // Index the counter to move through gear ratio profile array.
          if (latchTripped != 1) { // If latch has not tripped (this is the first time conditions are met)...
            indexLatchTripped = [i]; // store index, so we have the time of latch, and...
            timeLatchTripped = time[i]; // convert to time, and...
            latchTripped = 1; // switch latchTripped from 0 to 1.
          }
        }
      } // End of main simulation loop.

      // Create final gear ratio vs time for graphing.
      var latchPadding = []; // Create array to fill with the first value of the gear ratio.
      var padding = indexLatchTripped; // Number of values to add to padding array.
      while (padding--) latchPadding[padding] = gearRatio[1]; // Fill padding array with first value of gear ratio.
      var finalGearRatio = latchPadding.concat(gearRatio); // Add padding array to gear ratio array and put in new array.
      finalGearRatio.length = gearRatio.length; // Trim new array to the length of the original gear ratio array.

      // Create the chart objects and link them to HTML elements
      {
        var chart01 = new google.visualization.LineChart(document.getElementById('chart_01'));
        var chart02 = new google.visualization.LineChart(document.getElementById('chart_02'));
        var chart03 = new google.visualization.LineChart(document.getElementById('chart_03'));
        var chart04 = new google.visualization.LineChart(document.getElementById('chart_04'));
        var chart05 = new google.visualization.LineChart(document.getElementById('chart_05'));
        var chart06 = new google.visualization.LineChart(document.getElementById('chart_06'));
        var chart07 = new google.visualization.LineChart(document.getElementById('chart_07'));
        var chart08 = new google.visualization.LineChart(document.getElementById('chart_08'));
        var chart09 = new google.visualization.LineChart(document.getElementById('chart_09'));
        var chart10 = new google.visualization.LineChart(document.getElementById('chart_10'));
        var chart11 = new google.visualization.LineChart(document.getElementById('chart_11'));
        var chart12 = new google.visualization.LineChart(document.getElementById('chart_12'));
        var chart13 = new google.visualization.LineChart(document.getElementById('chart_13'));
        var chart14 = new google.visualization.LineChart(document.getElementById('chart_14'));
        var chart15 = new google.visualization.LineChart(document.getElementById('chart_15'));
      }

      // Place chart options into an object
      var options = { // Display options, such as line thickness, color, axis settings.
        backgroundColor: '#efefef',
        title: ' ',
        tooltip: {
          trigger: 'selection',
        },
        legend: 'none',
        lineWidth: 1.8,
        //
        chartArea: {
          backgroundColor: '#fdfdfd',
          left: '15%',
          top: '15%',
          width: '77%',
          height: '60%'
        },
        fontName: 'Lucida Grande',
        fontSize: 12,
        hAxis: {
          format: '#.####',
          title: 'Time (s)',
          minValue: 0,
          maxValue: duration
        },
        vAxis: {
          format: '#.####'
        },
        colors: ['royalblue', 'royalblue'],
      } // End of chart options
      var shortTime = downSample(time); // downSample the time array for faster graphing.

      // Create data arrays for graphs, using transpose fn.
      var data01 = new google.visualization.DataTable(); // Create the chart data table
      data01.addColumn('number', ''); // Add a column for one variable
      data01.addColumn('number', ''); // Add a column for a sceond variable
      data01.addRows(transpose([shortTime, downSample(muscleLength)])); // Add the data as rows, using the transpose function defined below to rotate a 2D array consisting of two vectors, x and y.
      var data02 = new google.visualization.DataTable();
      data02.addColumn('number', '');
      data02.addColumn('number', '');
      data02.addRows(transpose([shortTime, downSample(muscleVel)]));

      // NOTE: removeColumns(columnIndex, numberOfColumns) can be used to remove data which can then be updated.
      var data03 = new google.visualization.DataTable();
      data03.addColumn('number', '');
      data03.addColumn('number', '');
      data03.addRows(transpose([shortTime, downSample(muscleForce)]));
      var data04 = new google.visualization.DataTable();
      data04.addColumn('number', '');
      data04.addColumn('number', '');
      data04.addRows(transpose([shortTime, downSample(musclePowermW)]));
      var data05 = new google.visualization.DataTable();
      data05.addColumn('number', '');
      data05.addColumn('number', '');
      data05.addRows(transpose([shortTime, downSample(projectilePos)]));
      var data06 = new google.visualization.DataTable();
      data06.addColumn('number', '');
      data06.addColumn('number', '');
      data06.addRows(transpose([shortTime, downSample(projectileVel)]));
      var data07 = new google.visualization.DataTable();
      data07.addColumn('number', '');
      data07.addColumn('number', '');
      data07.addRows(transpose([shortTime, downSample(projectileAcc)]));
      var data08 = new google.visualization.DataTable();
      data08.addColumn('number', '');
      data08.addColumn('number', '');
      data08.addRows(transpose([shortTime, downSample(projectilePower)]));
      var data09 = new google.visualization.DataTable();
      data09.addColumn('number', '');
      data09.addColumn('number', '');
      data09.addRows(transpose([shortTime, downSample(springLength)]));
      var data10 = new google.visualization.DataTable();
      data10.addColumn('number', '');
      data10.addColumn('number', '');
      data10.addRows(transpose([shortTime, downSample(springVel)]));
      var data11 = new google.visualization.DataTable();
      data11.addColumn('number', '');
      data11.addColumn('number', '');
      data11.addRows(transpose([shortTime, downSample(muscleExcForce)]));
      var data13 = new google.visualization.DataTable();
      data13.addColumn('number', '');
      data13.addColumn('number', '');
      data13.addRows(transpose([shortTime, downSample(muscleWorkmJ)]));
      var data12 = new google.visualization.DataTable();
      data12.addColumn('number', '');
      data12.addColumn('number', '');
      data12.addColumn('number', '');
      data12.addRows(transpose([downSample(muscleLength), downSample(muscleFLForce), downSample(muscleRelForce)]));
      var data14 = new google.visualization.DataTable();
      data14.addColumn('number', '');
      data14.addColumn('number', '');
      data14.addColumn('number', '');
      data14.addRows(transpose([downSample(muscleVel), downSample(muscleFVForce), downSample(muscleForce)]));
      var data15 = new google.visualization.DataTable();
      data15.addColumn('number', '');
      data15.addColumn('number', '');
      data15.addRows(transpose([shortTime, downSample(finalGearRatio)]));

      // Call the draw function on the charts.
      options.title = 'Muscle Length (m)'; // Replace options for any subsequent graphs created.
      options.colors = ['#c91700'];
      chart01.draw(data01, options);
      options.title = 'Muscle Velocity (m/s)'; // Remember, these options are inherited by the graphs below.
      options.colors = ['#c91700'];
      chart02.draw(data02, options);
      options.title = 'Muscle Force (N)';
      options.colors = ['#c91700'];
      chart03.draw(data03, options);
      options.title = 'Muscle Power (mW)';
      options.colors = ['#c91700'];
      chart04.draw(data04, options);
      options.title = 'Projectile Position (m)';
      options.colors = ['royalblue'];
      chart05.draw(data05, options);
      options.title = 'Projectile Velocity (m/s)';
      options.colors = ['royalblue'];
      chart06.draw(data06, options);
      options.title = 'Projectile Acceleration (m/s/s)'; // Remember, these options are inherited by the graphs below.
      options.colors = ['royalblue'];
      chart07.draw(data07, options);
      options.title = 'Projectile Power (W/kg)';
      options.colors = ['royalblue'];
      chart08.draw(data08, options);
      options.title = 'Spring Length (m)';
      options.colors = ['#158032'];
      chart09.draw(data09, options);
      options.title = 'Spring Shortening Velocity (m/s)';
      options.colors = ['#158032'];
      chart10.draw(data10, options);
      options.title = 'Muscle Excitation'; // Remember, these options are inherited by the graphs below.
      options.colors = ['#c91700'];
      chart11.draw(data11, options);
      options.title = 'Muscle Work (mJ)';
      options.colors = ['#c91700'];
      chart13.draw(data13, options);
      options.title = 'Muscle Rel. Force vs Length';
      options.colors = ['#e5a8a1', '#5d39d3'];
      options.hAxis.title = 'Muscle length (m)';
      options.hAxis.minValue = muscleL0 * 0.5;
      options.hAxis.maxValue = muscleL0 * 1.5;
      chart12.draw(data12, options);
      options.title = 'Muscle Force vs Velocity'; // Remember, these options are inherited by the graphs below.
      options.colors = ['#e5a8a1', '#5d39d3'];
      options.hAxis.title = 'Muscle velocity (m/s)';
      options.hAxis.minValue = 0;
      options.hAxis.maxValue = muscleVmax;
      chart14.draw(data14, options);
      options.title = 'Gear Ratio Profile';
      options.colors = ['#000000'];
      options.hAxis.title = 'Time (s)';
      options.hAxis.minValue = 0;
      options.hAxis.maxValue = duration;
      options.vAxis.minValue = 0;
      options.vAxis.maxValue = maxGearRatio;
      chart15.draw(data15, options);

      allLabels = ["", "Time (s)", "Muscle Length (m)", "Muscle Force (N)", "Muscle Velocity (m/s)", "Muscle Power (W)", "Muscle Work (mJ)", "Projectile Position (m)", "Projectile Velocity (m/s)", "Projectile Acceleration (m/s/s)", "Projectile Power (W/kg)", "Spring Length (m)", "Spring Velocity (m/s)", "Muscle Excitation (%)", "Gear Ratio", "\n"]; // Collects all variable names to place in header column of data file.
      allSettings = []; // TODO: Collect all the settings to save to the data file.
      allData = [
        [allLabels],
        [transpose([time, muscleLength, muscleForce, muscleVel, musclePower, muscleWorkmJ, projectilePos, projectileVel, projectileAcc, projectilePower, springLength, springVel, muscleExcForce, finalGearRatio, endOfRow])]
      ];
      // TODO: Create an array with variable names, and then add that and all the data to allData.
      // TODO: Figure out how to save piecemeal to a csv file, because the current exportToCsv does not work for more than about 40,000 items.
      // downloadFile(allData, "MusExpData" + (1503700000000 - Date.now()) + ".csv");
    } // End of muscleSim function.

    // Downsample array for much, much faster graphing. More than about 500-800 points isn't necessary because you can't see them.
    function downSample(longArray) {
      var shortLength = 800;
      var shortArray = new Array(shortLength);
      var scaleFactor = Math.round(longArray.length / shortLength); // Create factor by which to skip values in long array.
      for (var i = 0; i < shortLength; ++i) { // Could probably do this with a .map function.
        //     shortArray[i] = Number(longArray[Math.round(i * scaleFactor) + 1].toPrecision(6));
        shortArray[i] = longArray[i * scaleFactor + 1]; // Grab value from long array and add to short array.
      }
      return shortArray;
    } // End of downSample function

    // Transpose 2D Array
    function transpose(original) { // Transpose 2D Array
      var copy = [];
      for (var i = 0; i < original.length; ++i) {
        for (var j = 0; j < original[i].length; ++j) {
          // skip undefined values to preserve sparse array
          if (original[i][j] === undefined) continue;
          // create row if it doesn't exist yet
          if (copy[j] === undefined) copy[j] = [];
          // swap the x and y coords for the copy
          copy[j][i] = original[i][j];
        }
      }
      return copy;
    } // End of transpose function.

    function downloadFile(data, fileName) {
      var csvData = data;
      var blob = new Blob([csvData], {
        type: "application/csv;charset=utf-8;"
      });

      if (window.navigator.msSaveBlob) {
        // FOR IE BROWSER
        navigator.msSaveBlob(blob, fileName);
      } else {
        // FOR OTHER BROWSERS
        var link = document.createElement("a");
        var csvUrl = URL.createObjectURL(blob);
        link.href = csvUrl;
        link.style = "visibility:hidden";
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    }

    // NOTE: To find the maximum value of array: Math.max.apply(Math, arrayName); [Math.max(arrayName); will not work!].

  </script>

</body>

</html>
