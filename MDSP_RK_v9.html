<!doctype html>
<html>

<head>
  <style>
    .graph {
      float: left;
      margin: 2px;
      padding: 0px;
      max-width: 600px;
      max-height: 300px;
      border: 0px solid #aaaaaa;
    }

    .controls {
      float: left;
      margin: 5px;
      padding: 2px;
      max-width: 600px;
      max-height: 200px;
      border: 0px solid #aaaaaa;
    }

    body {
      font-family: arial;
    }

  </style>
</head>

<body onload="springMass();">

  <div class="graph" id="chart_01"></div>
  <div class="graph" id="chart_02"></div>
  <div class="graph" id="chart_03"></div>
  <div class="graph" id="chart_04"></div>
  <div class="graph" id="chart_05"></div>
  <div class="graph" id="chart_06"></div>
  <div class="graph" id="chart_07"></div>
  <div class="graph" id="chart_08"></div>
  <div class="graph" id="chart_09"></div>
  <div class="graph" id="chart_10"></div>
  <div class="graph" id="chart_11"></div>
  <div class="graph" id="chart_12"></div>
  <div class="graph" id="chart_13"></div>
  <div class="graph" id="chart_14"></div>
  <div class="graph" id="chart_15"></div>
  <div class="graph" id="chart_16"></div>

  <div class="controls">
    Duration (s):
    <input type="number" id="duration" value="0.2">

    <p>Steps:<input type="number" id="steps" value="100000">
    </p>
    <p>
      Mass (kg):
      <input type="number" id="mass" value="10">
    </p>
    <p>
      Spring Constant (N/m):
      <input type="number" id="spring" value="10">
    </p>
    <p>
      Damping coefficient (N s/m):
      <input type="number" id="damper" value="0.1">
    </p>
    <p>
      Starting position (m):
      <input type="number" id="startPos-input" value="1">
    </p>
    <button onclick="location.reload()">Reset and Reload</button>
    <button id="runSim" onclick="springMass()">Apply New Values</button>
  </div>

  <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
  <script type="text/javascript">
    /*   Spring-Mass model looping example. Example of Runge-Kutta 4th Order (RK4) integration. At large time steps, RK4 performs well because it is refining the estimate in each time step by taking a weighted average of four estimates. Other integrators like Euler and Verlet need absurdly small time steps for the same accuracy, which on balance is not as efficient. RK4 is the gold standard. Author: Stephen M. Deban, University of South Florida. */

    // Load google chart API for graphing.
    google.charts.load('current', {
      'packages': ['corechart']
    }); // Load the corechart package which has line charts and others.


    //Simulation settings

    function springMass() { // Start of main simulation function


      // Get values from form in webpage. NOTE: '+' coerces the strings retrieved to numbers. Default values are stored in the form elements in the html.
      var duration = +document.getElementById("duration").value; // Duration in seconds.
      var steps = +document.getElementById("steps").value; // Steps in simulation.
      var mass = +document.getElementById("mass").value; // Mass in kg.
      var springConstant = +document.getElementById("spring").value; // Spring constant in N/m.
      var dampingConstant = +document.getElementById("damper").value; // Damping constant in Ns/m of damper on muscle mass. Damping may reduce fast oscillation of muscle mass.
      var startPosition = +document.getElementById("startPos-input").value; // Starting displacement of spring in m.

      var timeStep = duration / steps; // Size in seconds of time step.
      var time = [];
      for (var i = 0; i != steps + 1; ++i) time[i] = i * timeStep // Loop to fill time vector with timesteps to be used in graphing. Numbers will not be precise at 14 decimal places, but it doesn't matter.

      // Morphological and physiological parameters
      var muscleL0 = 0.02; // Muscle resting length in meters.
      var muscleP0 = 0.15; // Muscle isometric tension in newtons.
      var muscleVmax = 0.3; // Muscle Vmax in m/s.
      var muscleStartLength = muscleL0 * 1.2; // Starting length of muscle. Greater than 1.0 will make it start on  descending limb of length-tension curve.
      var shapeFV = 3; // Curvature of force-velocity relation. Larger values are more curved, with 0 a straight line. Value of 3 is about what frog limb muscle shows. To convert to and from Marsh and Bennett's power ratio use powerRatio=1/(shapeFV+2*sqrt(shapeFV+1)+2) and shapeFV=(1-2*sqrt(powerRatio))/powerRatio
      var powerRatio = 1 / (shapeFV + 2 * Math.sqrt(shapeFV + 1) + 2); // Convert shapeFV to power ratio.
      var muscleMass = 1e-05; // Combined mass of projector muscles in kg. 8e-06 is realistic.
      var projectileMass = 1e-05; // Mass of tongue projectile in kg. 1.6e-05 is realistic.
      var springK = 20; // Tendon spring constant in N/m. Realistic values not known.
      var springL0 = 0.02; // Tendon slack length in m.
      var muscleFraction = 0.3; // Fraction of muscle mass that is modeled as accelerated muscle mass. Needs to be at least 0.3 or oscillations will occur unless time step is tiny.
      var exciteTime = 0.04; // Time for muscle excitation in seconds.
      var excitationRate = 2; // Higher numbers have higher peak rate of excitation. Must be greater than 1.


      // Trial parameters that can change between trials.
      // One or more of these conditions can be used to release latch, depending on which if statements in loop are active. The first condition reached will release latch.
      var latchTime = 0.08; // Timing of latch release in seconds from start of simulation, if used in loop.
      var forceThreshold = muscleP0 * 0.9; // Muscle force at which gear ratio drops to 1.
      var lengthThreshold = 0.3; // Muscle length as percent of starting length at which gear ratio drops to 1.
      var latchTripped = 0; // Sets latch sensor to 0, to allow time of latch release to be captured regardless of condition that triggered it.
      var indexLatchTripped = 0;
      var timeLatchTripped = 0;
      var maxGearRatio = 10000; // gear ratio at start of trial.
      var minGearRatio = 1; // final gear ratio value during launch.
      var durationGearChange = 0.001; // Duration of latch release. Value near time step is effectively instantaneous.


      // Define arrays of proper length to fill with values later.
      var muscleLTForce = [];
      var muscleForce = [];
      var musclePower = [];
      var muscleWork = [];
      var springLength = [];
      var springForce = [];
      var projectilePos = [];
      var projectileVel = [];
      var projectileAcc = [];
      var projectilePower = [];


      // Define function to generate muscle tension given length.
      function muscleLTCurve(length) {
        if (length >= 0.6244 && length <= 1.6) {
          var tension = -34.045 * length ** 5 + 204.74 * length ** 4 - 470.16 * length ** 3 + 512.43 * length ** 2 - 262.9 * length + 50.936; // Takes muscle length relative to L0 from 0 to 1.6 with 1.0 as L0. Up to 1.4 is reliable and based on research values, but up to 1.6 is extrapolated to yield high force values if muscle is stretched. Beyond 1.6 is unreliable, so force at 1.6 is returned.
        } else if (length > 1.6) {
          tension = 1.137805;
        } else if (length < 0.6244) {
          tension = 0;
        }
        return (tension);
      } // Muscle LT function




      // Create gear ratio profile
      var gearRatioChange = time.map(function(i) {
        return ((1.00098 * maxGearRatio - minGearRatio) / (1 + 2 ** ((10 * (-(2 * i + (-durationGearChange))) / -durationGearChange))) + minGearRatio);
      }); // Create a sigmoidal gear ratio profile, starting to change from max to min at time zero over the specified duration.
      var gearRatio = time.map(function() {
        return gearRatioChange[0];
      }); // Fill gear ratio vector with starting value of gear ratio change, which is extremely close to the maximum input into the equation (but not exact).

      // NOTE: To find the maximum value of array: Math.max.apply(Math, arrayName); [Math.max(arrayName); will not work].

      // First time step in simulation.
      // Muscle, spring, projectile and gearing starting conditions.
      var exciteMax = 1; // Maximum excitation level of muscle, with 1 being full excitation.
      var muscleAcc = [];
      muscleAcc[0] = 0; // Starting acceleration of muscle mass in m/s/s.
      var muscleLength = [];
      muscleLength[0] = muscleStartLength; // Starting muscle length in m, set to muscle resting length.
      var muscleVel = [];
      muscleVel[0] = 0; // Starting velocity of muscle shortening in m/s.
      springLength[0] = springL0; // Starting tendon length in m, set to tendon slack length.
      projectileVel[0] = 0; // Starting velocity of tongue (projectile) mass in m/s.
      projectileAcc[0] = 0; // Starting acceleration of tongue (projectile) mass in m/s/s.
      projectilePos[0] = muscleLength[0] + springLength[0]; // Starting position of tongue projectile is defined as sum of starting muscle and spring lengths.
      var muscleExcForce = time.map(function(i) {
        return exciteMax / (1 + excitationRate ** ((10 * (-2 * i + exciteTime) / exciteTime)));
      }); // Defines entire muscle excitation profile array, ramping up from zero to max defined as exciteMax in a sigmoidal fashion by exciteTime.
      muscleLTForce[0] = muscleLTCurve(muscleLength[0] / muscleL0); // Call function muscleLTCurve to return tension from length. See notes below for an explanation.
      var muscleFVForce = [];
      muscleFVForce[0] = (muscleP0 * (muscleVmax - muscleVel[0])) / (shapeFV * muscleVel[0] + muscleVmax); // Equation specifying muscle force given muscleVmax, muscleVel, muscleP0 and a shape. Symmetric around force=velocity.
      muscleForce[0] = muscleFVForce[0] * muscleLTForce[0] * muscleExcForce[0] > 0 ?
        muscleFVForce[0] * muscleLTForce[0] * muscleExcForce[0] : 0; // Final muscle force, calculated from muscle length, velocity and excitation at first time step. Constrained to be positive because a muscle cannot push. Positive when muscle is shortening.
      springForce[0] = (springLength[0] - springL0) * springK > 0 ?
        (springLength[0] - springL0) * springK : 0; // Spring force is calculated from tendon length relative to slack length, and spring constant at current time step, as a Hookean spring: F=kx. F=(current length-slack length)*spring constant. Constrained to be positive or zero because a tendon cannot push. Positive is shortening tendon and projecting tongue mass.
      musclePower[0] = muscleVel[0] * muscleAcc[0]; // Calculate mass specific muscle power.


      // TODO: Add calculations for muscle work and power inside the loop, to add to array at each time step.

      // Simulation loop: second time step and onward using Runge-Kutta 4th order integration"
      var i = 0; // Set index to 0 so that loop starts with array value 1 (i.e., step 2)

      while (i < steps) { // Loop from 1 (the second step) to number of steps in simulation because arrays start at zero.
        i = i + 1; // Increment index.

        // Calculate first of four parts of Runge-Kutta weighted average. Muscle and projectile mass acceleration, velocity, and position are calculated from muscle and tendon (spring) forces.
        var muscleLength1 = muscleLength[i - 1]; // Last position of muscle mass, to be used in Runge-Kutta integration.
        var muscleVel1 = muscleVel[i - 1]; // Last velocity of muscle shortening, to be used in Runge-Kutta integration
        var projectilePos1 = projectilePos[i - 1]; // Last position of projectile mass.
        var projectileVel1 = projectileVel[i - 1]; // Last velocity of projectile mass.
        var springLength1 = springLength[i - 1]; // Last spring length.
        var springForce1 = springForce[i - 1]; // Last spring force to be used in calculation of projectile acceleration.
        var muscleForce1 = muscleForce[i - 1]; // Last muscle force to be used in calculation of muscle acceleration.
        var muscleAcc1 = (muscleForce1 - springForce1 - dampingConstant * muscleVel1) /
          (muscleMass * muscleFraction); // Muscle mass acceleration is calculated by balance of forces from tendon and muscle in previous time step, using a=F/m: a=(previous muscle force-previous tendon force)/(muscle mass*fraction of muscle mass accelerated). Positive is increasing muscle shortening velocity. Acceleration corresponding to last length and velocity, to be used in Runge-Kutta integration.
        var projectileAcc1 = springForce1 / projectileMass / gearRatio[i]; // Projectile mass acceleration is calculated using tendon force divided by gear ratio, as a=F/m: a=previous tendon force/projectile mass/gear ratio. Positive or zero. Positive is increasing projection velocity of projectile.

        // Calculate second of four parts of Runge-Kutta weighted average.
        var muscleLength2 = muscleLength1 + muscleVel1 * timeStep / 2; // Intermediate muscle length estimate to be averaged into final estimate using Runge-Kutta integration.
        var muscleVel2 = muscleVel1 + muscleAcc1 * timeStep / 2; // Intermediate muscle velocity estimate.
        var projectilePos2 = projectilePos1 + projectileVel1 * timeStep / 2; // Intermediate projectile position estimate to be averaged into final estimate using Runge-Kutta integration.
        var projectileVel2 = projectileVel1 + projectileAcc1 * timeStep / 2; // Intermediate projectile velocity estimate.
        var muscleLTForce2 = muscleLTCurve(muscleLength2 / muscleL0); // Intermediate muscle tension multiplier based on length.
        var muscleFVForce2 = (muscleP0 * (muscleVmax - muscleVel2)) /
          (shapeFV * muscleVel2 + muscleVmax); // Intermediate muscle force based on FV curve. Equation specifying muscle force given muscleVmax, muscleVel, muscleP0 and a shape. Symmetric around force=velocity.
        var muscleForce2 = muscleFVForce2 * muscleLTForce2 * muscleExcForce[i] > 0 ?
          muscleFVForce2 * muscleLTForce2 * muscleExcForce[i] : 0; // Total intermediate muscle force, calculated from muscle length, velocity and excitation at first time step. Constrain muscleForce to be positive because a muscle cannot push. Postitive when muscle is shortening.
        var springLength2 = projectilePos2 - muscleLength2; // Spring length is calculated from muscle length and projectile mass position, as projectile mass position - muscle length.
        var springForce2 = (springLength2 - springL0) * springK > 0 ?
          (springLength2 - springL0) * springK : 0;
        var muscleAcc2 = (muscleForce2 - springForce2 - dampingConstant * muscleVel2) /
          (muscleMass * muscleFraction); // Muscle mass acceleration is calculated by balance of forces from tendon and muscle
        var projectileAcc2 = springForce2 / projectileMass / gearRatio[i];

        // Calculate third of four parts of Runge-Kutta weighted average.
        var muscleLength3 = muscleLength1 + muscleVel2 * timeStep / 2;
        var muscleVel3 = muscleVel1 + muscleAcc2 * timeStep / 2;
        var projectilePos3 = projectilePos1 + projectileVel2 * timeStep / 2;
        var projectileVel3 = projectileVel1 + projectileAcc2 * timeStep / 2;
        var muscleLTForce3 = muscleLTCurve(muscleLength3 / muscleL0);
        var muscleFVForce3 = (muscleP0 * (muscleVmax - muscleVel3)) / (shapeFV * muscleVel3 + muscleVmax);
        var muscleForce3 = muscleFVForce3 * muscleLTForce3 * muscleExcForce[i] > 0 ?
          muscleFVForce3 * muscleLTForce3 * muscleExcForce[i] : 0;
        var springLength3 = projectilePos3 - muscleLength3;
        var springForce3 = (springLength3 - springL0) * springK > 0 ?
          (springLength3 - springL0) * springK : 0;
        var muscleAcc3 = (muscleForce3 - springForce3 - dampingConstant * muscleVel3) /
          (muscleMass * muscleFraction);
        var projectileAcc3 = springForce3 / projectileMass / gearRatio[i];

        // Calculate fourth of four parts of Runge-Kutta weighted average. Note timestep is not divided by two.
        var muscleLength4 = muscleLength1 + muscleVel3 * timeStep;
        var muscleVel4 = muscleVel1 + muscleAcc3 * timeStep;
        var projectilePos4 = projectilePos1 + projectileVel3 * timeStep;
        var projectileVel4 = projectileVel1 + projectileAcc3 * timeStep;
        var muscleLTForce4 = muscleLTCurve(muscleLength4 / muscleL0);
        var muscleFVForce4 = (muscleP0 * (muscleVmax - muscleVel4)) /
          (shapeFV * muscleVel4 + muscleVmax);
        var muscleForce4 = muscleFVForce4 * muscleLTForce4 * muscleExcForce[i] > 0 ?
          muscleFVForce4 * muscleLTForce4 * muscleExcForce[i] : 0;
        var springLength4 = projectilePos4 - muscleLength4;
        var springForce4 = (springLength4 - springL0) * springK > 0 ?
          (springLength4 - springL0) * springK : 0;
        var muscleAcc4 = (muscleForce4 - springForce4 - dampingConstant * muscleVel4) / (muscleMass * muscleFraction);
        var projectileAcc4 = springForce4 / projectileMass / gearRatio[i];

        // Calculate new positions and velocities by weighted average.
        muscleLength[i] = muscleLength[i - 1] - (muscleVel1 + muscleVel2 * 2 + muscleVel3 * 2 + muscleVel4) *
          timeStep / 6; // Weighted average of four estimates of muscle length, put into vector as definitive muscle length at this time step. Length change is subtracted from old length because muscle is shortening.
        muscleLength[i] = muscleLength[i] > 0.7 * muscleL0 ?
          muscleLength[i] : muscleLength[i - 1]; // If muscle strain is greater than specified amount, then previous length is used, to prevent extreme shortening.
        muscleVel[i] = muscleVel[i - 1] + (muscleAcc1 + muscleAcc2 * 2 + muscleAcc3 * 2 + muscleAcc4) *
          timeStep / 6; // Weighted average of four estimates of muscle velocity, put into vector as definitive muscle velocity at this time step.
        projectilePos[i] = projectilePos[i - 1] - (projectileVel1 + projectileVel2 * 2 + projectileVel3 * 2 + projectileVel4) * timeStep / 6; // Weighted average of four estimates of projectile position, put into vector as definitive position at this time step. Position change is subtracted from old position because spring is shortening.
        projectileVel[i] = projectileVel[i - 1] + (projectileAcc1 + projectileAcc2 * 2 + projectileAcc3 * 2 + projectileAcc4) * timeStep / 6; // Weighted average of four estimates of projectile velocity, put into vector as definitive velocity at this time step.

        // Calculate definitive muscle force acceleration, spring length and force, and projectile acceleration for this time step.
        muscleLTForce[i] = muscleLTCurve(muscleLength[i] / muscleL0);
        muscleFVForce[i] = (muscleP0 * (muscleVmax - muscleVel[i])) / (shapeFV * muscleVel[i] + muscleVmax);
        muscleForce[i] = muscleFVForce[i] * muscleLTForce[i] * muscleExcForce[i] > 0 ?
          muscleFVForce[i] * muscleLTForce[i] * muscleExcForce[i] : 0;
        springLength[i] = projectilePos[i] - muscleLength[i]; // Calculate definitive spring length for this time step.
        springForce[i] = (springLength[i] - springL0) * springK > 0 ?
          (springLength[i] - springL0) * springK : 0; // Definitive spring force for this time step.
        muscleAcc[i] = (muscleForce[i] - springForce[i] - dampingConstant *
          muscleVel[i]) / (muscleMass * muscleFraction); // Definitive muscle mass acceleration for this time step.
        projectileAcc[i] = springForce[i] / projectileMass / gearRatio[i]; // Definitive projectile acceleration for this time step.

        // Calculate power and work
        musclePower[i] = muscleVel[i] * muscleForce[i]; // Calculate absolute muscle power in W.



        // Test for various conditions to determine when latch releases.
        if (latchTripped == 0) {
          if (muscleLength[i] < lengthThreshold * muscleLength[1]) {
            gearRatio.splice(i, gearRatioChange); // Asks if muscle length is below threshold value specified, and if so, it makes gear ratio from this point onward transition to final value.
            latchTripped = 1
          }

          if (muscleForce[i] > forceThreshold) {
            gearRatio.splice(i, gearRatioChange); // Asks if muscle force is above threshold value specified, and if so, it makes gear ratio from this point onward transition to final value.
            latchTripped = 1
          }

          if (time[i] > latchTime) {
            gearRatio.splice(i, gearRatioChange); // Condition for release of latch at specified time, if this is used.
            latchTripped = 1
          }

          timeLatchTripped = time[i]; // Record time latch was tripped. This will keep changing until latch is tripped.
          indexLatchTripped = i; // iteration number at which latch tripped.
        }
      } // End of main simulation loop.

      // alert("Done!");
      // Create the chart objects and link them to HTML elements
      {
        var chart1 = new google.visualization.LineChart(document.getElementById('chart_01'));
        var chart2 = new google.visualization.LineChart(document.getElementById('chart_02'));
        var chart3 = new google.visualization.LineChart(document.getElementById('chart_03'));
        var chart4 = new google.visualization.LineChart(document.getElementById('chart_04'));
        var chart5 = new google.visualization.LineChart(document.getElementById('chart_05'));
        var chart6 = new google.visualization.LineChart(document.getElementById('chart_06'));
        var chart7 = new google.visualization.LineChart(document.getElementById('chart_07'));
        var chart8 = new google.visualization.LineChart(document.getElementById('chart_08'));
        var chart9 = new google.visualization.LineChart(document.getElementById('chart_09'));
        var chart10 = new google.visualization.LineChart(document.getElementById('chart_10'));
        var chart11 = new google.visualization.LineChart(document.getElementById('chart_11'));
        var chart12 = new google.visualization.LineChart(document.getElementById('chart_12'));
        var chart13 = new google.visualization.LineChart(document.getElementById('chart_13'));
        var chart14 = new google.visualization.LineChart(document.getElementById('chart_14'));
        var chart15 = new google.visualization.LineChart(document.getElementById('chart_15'));
        var chart16 = new google.visualization.LineChart(document.getElementById('chart_16'));
      }

      // Place chart options into an object
      var options = { // Display options, such as line thickness, color.
        backgroundColor: '#f0f0f0',
        title: ' ',
        tooltip: {
          trigger: 'selection'
        },
        legend: 'none',
        lineWidth: 1,
        //
        chartArea: {
          backgroundColor: '#f8f8f8',

          left: 55,
          top: 22,
          width: '80%',
          height: '65%'
        },
        fontSize: 14,
        hAxis: {
          title: 'Time (s)',
        },
        colors: ['#286ad1']
      } // Chart options

      var shortTime = downsample(time); // Downsample the time array for faster graphing.

      // Create data arrays for graphs, using transpose fn.
      var data01 = new google.visualization.DataTable(); // Create the chart data table
      data01.addColumn('number', ''); // Add a column for one variable
      data01.addColumn('number', ''); // Add a column for a sceond variable
      data01.addRows(transpose([shortTime, downsample(muscleLength)])); // Add the data as rows, using the transpose function defined below to rotate a 2D array consisting of two vectors, x and y.

      var data02 = new google.visualization.DataTable();
      data02.addColumn('number', '');
      data02.addColumn('number', '');
      data02.addRows(transpose([shortTime, downsample(muscleVel)]));

      var data03 = new google.visualization.DataTable();
      data03.addColumn('number', '');
      data03.addColumn('number', '');
      data03.addRows(transpose([shortTime, downsample(muscleForce)]));

      var data04 = new google.visualization.DataTable();
      data04.addColumn('number', '');
      data04.addColumn('number', '');
      data04.addRows(transpose([shortTime, downsample(musclePower)]));

      var data05 = new google.visualization.DataTable();
      data05.addColumn('number', '');
      data05.addColumn('number', '');
      data05.addRows(transpose([shortTime, downsample(projectilePos)]));

      var data06 = new google.visualization.DataTable();
      data06.addColumn('number', '');
      data06.addColumn('number', '');
      data06.addRows(transpose([shortTime, downsample(projectileVel)]));

      var data07 = new google.visualization.DataTable();
      data07.addColumn('number', '');
      data07.addColumn('number', '');
      data07.addRows(transpose([shortTime, downsample(projectileAcc)]));

      var data08 = new google.visualization.DataTable();
      data08.addColumn('number', '');
      data08.addColumn('number', '');
      data08.addRows(transpose([shortTime, downsample(projectileAcc)]));

      var data09 = new google.visualization.DataTable();
      data09.addColumn('number', '');
      data09.addColumn('number', '');
      data09.addRows(transpose([shortTime, downsample(projectileAcc)]));

      var data10 = new google.visualization.DataTable();
      data10.addColumn('number', '');
      data10.addColumn('number', '');
      data10.addRows(transpose([shortTime, downsample(projectileAcc)]));

      var data11 = new google.visualization.DataTable();
      data11.addColumn('number', '');
      data11.addColumn('number', '');
      data11.addRows(transpose([shortTime, downsample(projectileAcc)]));

      var data12 = new google.visualization.DataTable();
      data12.addColumn('number', '');
      data12.addColumn('number', '');
      data12.addRows(transpose([shortTime, downsample(projectileAcc)]));

      var data13 = new google.visualization.DataTable();
      data13.addColumn('number', '');
      data13.addColumn('number', '');
      data13.addRows(transpose([shortTime, downsample(projectileAcc)]));

      var data14 = new google.visualization.DataTable();
      data14.addColumn('number', '');
      data14.addColumn('number', '');
      data14.addRows(transpose([shortTime, downsample(projectileAcc)]));

      var data15 = new google.visualization.DataTable();
      data15.addColumn('number', '');
      data15.addColumn('number', '');
      data15.addRows(transpose([shortTime, downsample(projectileAcc)]));

      var data16 = new google.visualization.DataTable();
      data16.addColumn('number', '');
      data16.addColumn('number', '');
      data16.addRows(transpose([shortTime, downsample(projectileAcc)]));



      // Call the draw function on the charts.
      options.title = 'Muscle Length (m)'; // Replace the vAxis label in the options for any subsequent graphs created.
      options.colors = ['#c91700'];
      chart1.draw(data01, options);

      options.title = 'Muscle Velocity (m/s)';
      options.colors = ['#c91700'];
      chart2.draw(data02, options);

      options.title = 'Muscle Force (N)';
      options.colors = ['#c91700'];
      chart3.draw(data03, options);

      options.title = 'Muscle Power (W)';
      options.colors = ['#c91700'];
      chart4.draw(data04, options);

      options.title = 'Projectile Position (m)';
      options.colors = ['#234cba'];
      chart5.draw(data05, options);

      options.title = 'Projectile Velocity (m/s)';
      options.colors = ['#234cba'];
      chart6.draw(data06, options);

      options.title = 'Projectile Acceleration (m/s/s)';
      options.colors = ['#234cba'];
      chart7.draw(data07, options);


    } // End of muscleSim function.

    // Downsample array to 1000 values for faster graphing
    function downsample(originalArray) {
      var newArray = [];
      var scaleFactor = Math.round(originalArray.length / 1000);
      for (var i = 0; i < 1000; ++i) { // Could probably do this with a .map function.
        newArray[i] = originalArray[Math.round(i * scaleFactor) + 1];
      }
      return newArray;
    } // End of downsample function


    // Transpose 2D Array
    function transpose(original) { // Transpose 2D Array
      var copy = [];
      for (var i = 0; i < original.length; ++i) {
        for (var j = 0; j < original[i].length; ++j) {
          // skip undefined values to preserve sparse array
          if (original[i][j] === undefined) continue;
          // create row if it doesn't exist yet
          if (copy[j] === undefined) copy[j] = [];
          // swap the x and y coords for the copy
          copy[j][i] = original[i][j];
        }
      }
      return copy;
    } // End of transpose function.

    // TODO: Example format for To Do.

  </script>

</body>

</html>
